# 正则表达式
参考[stackoverflow关于正则](https://stackoverflow.com/questions/22937618/reference-what-does-this-regex-mean/22944075)
参考[perl正则](https://www.junmajinlong.com/perl/perl_re/)
## 特殊字符
. [ { ( ) \ * + ? | ^ $
## 通配符
. 在字符集之外使用时可以匹配任意单字符。
## 锚点
'^'字符会匹配行的起始。
'$'字符会匹配行的终止。
## 标记子表达式
在()之间的部分是被标记的子表达式，匹配算法会将子表达式匹配的部分分离成独立的部分。 标记子表达式可以被重复，或后向引用。
## 非标记组
标记子表达式对于正则表达式中的成组文字部分是非常有用的，但将结果分组是有副作用的。 作为选择，可以通过 (?: expression)产生文字分组，但不产生标记子表达式，例如 (?:ab)+ 会重复 ab 但并不分隔出单独的子表达式。
## 重复
任意原子(单个字符，一个标记子表达式或一个字符组)可以通过 *, +, ? 和 {} 操作符重复。

| 操作符 | 说明                       |
| ------ | -------------------------- |
| *      | 匹配前面的原子零次或多次   |
| +      | 匹配前面的原子一次或多次   |
| ?      | 匹配前面的原子零次或一次   |
| {n}    | 匹配前面的原子n次          |
| {n,}   | 匹配前面的原子n次或更多次  |
| {n,m}  | 匹配前面的原子n次到m次之间 |

## 非贪婪重复

| 操作符 | 说明                                            |
| ------ | ----------------------------------------------- |
| *?     | 匹配前面的原子零次或多次，但尽可能少地消耗输入  |
| +?     | 匹配前面的原子一次或多次，但尽可能少地消耗输入  |
| ??     | 匹配前面的原子零次或一次，但尽可能少地消耗输入  |
| {n,}?  | 匹配前面的原子n次或更多次，但尽可能少地消耗输入 |
| {n,m}? | 匹配前面的原子n次到m次，但尽可能少地消耗输入    |

## Pocessive 重复
缺省情况下，当一个重复模式不能被匹配时，引擎将回溯直至找到一个匹配。但是，有时候这种行为不是用户所期望的， 因此还有一种”pocessive”重复：它尽可能多地进行匹配且当剩下的表达式不能匹配时不允许进行回溯。

| 操作符 | 说明                               |
| ------ | ---------------------------------- |
| *+     | 匹配前面的原子零次或多次，但不退回 |
| ++     | 匹配前面的原子一次或多次，但不退回 |
| ?+     | 匹配前面的原子零次或一次，但不退回 |
| {n,}+  | 匹配前面的原子n次或多次，但不退回  |
| {n,m}+ | 匹配前面的原子n次到m次，但不退回   |

## 后向引用
- 一个转义字符跟着一个数字\n，n的范围是1-9，匹配被子表达式n匹配的相同字符串，如：^(a*).*\1$匹配 aaabbaaa但不匹配aaabba
- \g转义符

| 操作符  | 说明                                                 |
| ------- | ---------------------------------------------------- |
| \g1     | 匹配子表达式1的内容                                  |
| \g{1}   | 匹配子表达式1的内容：更安全的方式如\g{1234} 或\g{1}2 |
| \g-1    | 匹配最后一个被打开的子表达式的内容                   |
| \g{-2}  | 匹配倒数第二个被打开的子表达式的内容                 |
| \g{one} | 匹配名为one的子表达式的内容                          |

- \k转义符可用于引用命名子表达式，如\k<two>将匹配名为two的子表达式的内容
## 选择
- | 操作符匹配它的参数之一，例如 abc|def 会匹配“abc”或“def”
- 括号可以用来对选择进行分组，例如：ab(d|ef) 会匹配 “abd” 或 “abef”。
- 空的选择是不允许的(这通常都是错误)，但如果真的需要一个空的选择，可以使用 (?:) 作为占位符，如
   - |abc 不是有效的表达式，但(?:)|abc 是有效的表达式，并且与(?:abc)?? 有完全相同的作用
## 字符集
字符集是一个[]方括号表达式，它定义了一个字符的集合，匹配集合中的任意单个字符。包含下面的组合：
- 单个字符：如[abc]可以匹配’a’, ’b’, 或 ’c’。
- 字符范围：如[a-c]可以匹配’a’ 到 ’c’范围内的任意单个字符
- 否定：如果方括号表达式以 ^ 字符开始，那么它匹配包含字符的补集，如：[^a-c]匹配不在a到c范围内的任意字符
- 字符类:形如[[:name:]]的表达式匹配命名字符类”name”，例如[[:lower:]]任意小写字符。参见字符类名称表
- 对照元素形如 [[.col.]] 的表达式匹配对照元素 /col/。对照元素是任意的单个字符，或对应于某个单个单元的字符序列。对照元素还可以用作范围的端点，例如 [[.ae.]-c] 匹配字符序列”ae”，和在范围”ae”到c之间的任意单个字符。 其中”ae”被当前locale处理为单个对照元素。作为扩展，对照元素可以通过其符号名指定，例如：[[.NUL.]] 匹配一个 \0 字符
- 等价类 形如 [[=col=]] 的表达式匹配主排序关键字等同于对照元素 col 的任意字符或对照元素，其中名字为 col 的对照元素可以是一个 符号名。主排序关键字忽略大小写、重音或特定区域(locale)的裁剪(tailorings)； 所以如 [[=a=]] 匹配下面的字符：a, À, Á, Â, Ã, Ä, Å, A, à, á, â, ã, ä 和 å。 不幸的是这个实现依赖于平台的对照(collation)和地区(localization)支持； 这个特性并不能很好地可移植工作于所有的平台，甚至一个平台上的所有区域(locale)。
- 转义字符 任意匹配单个字符或单个字符类的转义序列都可以定义在字符类中。例如[\[\]] 可以匹配 [ 或 ] ，而 [\W\d]可以匹配任何“数字”字符或者任何不是”单词”的字符。
- 组合: 所有上面的都可以在一个字符类声明中被组合，例如 [[:digit:]a-c[.NUL.]]。
## 转义符
任意特殊字符前面加转义符都匹配自己。
下面的转义序列和单个字符同义

| 操作符   | 说明                                               |
| -------- | -------------------------------------------------- |
| \a       | \a                                                 |
| \e       | 0x1B                                               |
| \f       | \f                                                 |
| \n       | \n                                                 |
| \r       | \r                                                 |
| \t       | \t                                                 |
| \v       | \v                                                 |
| \b       | \b(仅在字符类声明中使用)                           |
| \cX      | 一个ASCII转义序列，字符码点为 X % 32               |
| \xdd     | 一个十六进制转义序列，匹配码点为0xdd的单个字符。   |
| \x{dddd} | 一个十六进制转义序列，匹配码点为0xdddd的单个字符。 |
| \0ddd    | 八进制转义序列，匹配码点为0ddd的单个字符。         |
| \N{name} | 匹配符号名为name的单个字符。                       |
## “单字符” 字符类

| 转义序列 | 等价于       |
| -------- | ------------ |
| \d       | [[:digit:]]  |
| \l       | [[:lower:]]  |
| \s       | [[:space:]]  |
| \u       | [[:upper:]]  |
| \w       | [[:word:]]   |
| \h       | 水平空白     |
| \v       | 垂直空白     |
| \D       | [^[:digit:]] |
| \L       | [^[:lower:]] |
| \S       | [^[:space:]] |
| \U       | [^[:upper:]] |
| \W       | [^[:word:]]  |
| \H       | 非水平空白   |
| \V       | 非垂直空白   |

## 字符属性
下面表格中的字符属性名称都等价于字符类中使用的名字。

| 形式     | 说明                         | 等价的字符集形式 |
| -------- | ---------------------------- | ---------------- |
| \pX      | 匹配任意具有属性X的字符      | [[:X:]]          |
| \p{Name} | 匹配任意具有属性Name的字符   | [[:Name:]]       |
| \PX      | 匹配任意不具有属性X的字符    | [^[:X:]]         |
| \P{Name} | 匹配任意不具有属性Name的字符 | [^[:Name:]]      |

例如 \pd 匹配任意的”数字”字符，和 \p{digit} 作用是一样的。
- 单词边界
下面的转义序列匹配单词的边界：
\< 匹配单词的起点
\> 匹配单词的终点
\b 匹配单词的边界（起点或终点）
\B 只有不在边界时才匹配。
- 缓冲区边界
下面的转义序列匹配缓冲区边界：这里的”缓冲区”指用于匹配的全部输入文本(注意，^和$可以用于匹配文本中的行)。
  -  ` 匹配缓冲区的起点。
  -  ' 匹配缓冲区的终点。
  -  \A 匹配缓冲区的起点(同 \` 一样)。
  -  \z 匹配缓冲区的终点(同 \’ 一样)。
  -  \Z 匹配一个零长度的断言，包括缓冲区结尾处可能存在的空行：等价于正则表达式 (?=\v*\z)。注意，这与 Perl 中匹配 (?=\n?\z) 的行为有一些微妙的不同。
- 持续转义
序列 \G 只在上次匹配结尾或匹配文本的起点(如果前面没有匹配)。 当你要迭代文本中所有的匹配，并且每个子序列都从上一次结束时开始匹配的话，这个转义是很有用的。
- 引用转义
引用转义 转义序列 \Q 开始一个”被引用序列”：所有后面的字符都被当作字面对待，除非正则表达式结束或碰到 \E。 例如，表达式：\Q\*+\Ea+ 可以匹配如下：*+a *+aaa
- Unicode转义
\C 匹配一个单一的码表：在 Boost.Regex 中这和”.”操作符的作用是完全相同的
\X 匹配一个组合字符序列：任意非组合字符跟上一个零或多个组合字符的序列
- 匹配行末符
转义序列 \R 匹配任何行末符序列，特别地，它等同于表达式 (?>\x0D\x0A?|[\x0A-\x0C\x85\x{2028}\x{2029}]).
- 回退一些文本
\K 将$0的开始位置重置为当前文本位置：换言之，\K 左边的所有东西被”退回”且不作为该正则表达式的匹配部分。 $ 也被相应更新。 例如，foo\Kbar 用于匹配文本 "foobar" 时，将对 $0 返回匹配 "bar"，对 $ 返回 “foo”。 这可以被用于模拟可变宽度的后向环视断言。
- 其他转义
其它转义序列匹配被转义的字符，例如 \@匹配 ‘@’

## 非捕获组
非捕获组（Non-Capturing Groups）在正则表达式中是一个非常有用的工具。它的主要意义在于增强正则表达式的灵活性和性能，同时避免不必要的捕获。
假设你有一个字符串 a1b2c3，并且你想匹配字母和数字的组合，但只捕获数字
```
(?:[a-z])(\d)
```
非捕获组的语法是 (?:...)，其中 ... 是你想要分组的正则表达式部分。

## 正向先行断言
正则表达式中的正向先行断言（positive lookahead assertion）是一种特殊的断言模式，用于匹配在某个位置之后满足特定条件的文本。正向先行断言在正则表达式中的存在意义是提供更精确、灵活和高效的模式匹配能力，以满足特定的匹配需求，并增强正则表达式的功能和应用范围。零宽度匹配：正向先行断言是零宽度匹配（zero-width match），即它们不消耗匹配项，也不包含在最终的匹配结果中。
例如，Date: 4 Aug 3PM,我们要匹配文本中的小时值。为了只匹配后面有 PM 的数值，我们需要在表达式后面使用正向先行断言 (?=)，并在括号内的 = 后面添加 PM。
```
\d+(?=PM)
```
## 负向先行断言
正则表达式中的负向先行断言（negative lookahead assertion）是一种特殊的断言模式，用于匹配在某个位置之后不满足特定条件的文本。负向先行断言是零宽度匹配（zero-width match），即它们不消耗匹配项，也不包含在最终的匹配结果中。这意味着我们可以在不影响最终结果的情况下，仅仅检查文本的一部分是否不满足某些条件
我们要在文本中匹配除小时值以外的数字。我们需要在表达式后面使用负向先行断言 (?!)，并在括号内的 ! 后面添加 PM，从而只匹配没有 PM 的数值.
```
\d+(?!PM)
```

## 正向后行断言
正向后行断言（positive lookbehind assertion）是正则表达式中的一种特殊断言模式，用于匹配在某个位置之前满足特定条件的文本。它的语法形式为(?<=...)，其中...表示要匹配的条件。正向后行断言是零宽度匹配（zero-width match），即它们不消耗匹配项，也不包含在最终的匹配结果中。这意味着我们可以在不影响最终结果的情况下，仅仅检查文本的一部分是否满足某些条件。
例如，我们要匹配文本Product Code: 1064 Price: $5中的金额数。为了只匹配前面带有 $ 的数字。我们要在表达式前面使用正向后行断言 (?<=)，并在括号内的 = 后面添加 \$。
```
(?<= \$\d+)
```
## 负向后行断言
例如，我们要在文本中匹配除价格外的数字。为了只匹配前面没有 $ 的数字，我们要在表达式前用负向后行断言 (?<!)，并在括号内的 ! 后面添加 \$。
```
(?<! \$\d+)
```



