# TCP
## 定义
TCP 是面向连接的、可靠的、基于字节流的传输层通信协议。
面向连接：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；
可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；
字节流：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。
用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。
建立一个 TCP 连接是需要客户端与服务端达成上述三个信息的共识：
- Socket：由 IP 地址和端口号组成
- 序列号：用于解决乱序问题。
- 窗口大小：用于流量控制。
TCP 四元组可以唯一的确定一个连接，四元组包括如下：
- 源地址
- 源端口
- 目的地址
- 目的端口
源地址和目的地址的字段（32 位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。
源端口和目的端口的字段（16 位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。
Q1:有一个 IP 的服务端监听了一个端口，它的 TCP 的最大连接数是多少？
理论值计算公式 = 客户端的ip数 * 客户端的端口数
实际上，客户端的 IP 数最多是 2 的 32 次方，客户端的端口数最多是 2 的 16 次方，所以 TCP 的最大连接数是 2 的 48 次方。
实际场景中，服务端最大并发 TCP 连接数远不能达到理论上限，会受以下因素影响：
- 文件描述符限制，每个 TCP 连接都是一个文件，如果文件描述符被占满了，会发生 Too many open files。Linux 对可打开的文件描述符的数量分别作了三个方面的限制：
    - 系统级：当前系统可打开的最大文件数，当前系统可打开的最大数量，通过 cat /proc/sys/fs/file-max 查看；
    - 用户级：当前用户可打开的最大文件数，指定用户可打开的最大数量，通过 cat /etc/security/limits.conf 查看；
    - 程序级：单个进程可打开的最大文件数，单个进程可打开的最大数量，通过 cat /proc/sys/fs/nr_open 查看；
    - 内存大小，每个 TCP 连接在内核中都会消耗一定的内存，操作系统的内存是有限的，如果内存不足，会发生 Out of memory。
    - 网络设备性能，例如带宽、网关、路由器等硬件设备，都会限制网络的最大速度。

## 协议构成
![TCP报文头部](https://cdn.jsdelivr.net/gh/zysok2023/cloudImg/blogs/picture/TCP报文头部.webp)

序列号：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。用来解决网络包乱序问题。

确认应答号：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题。

控制位：
- ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。
- RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。
- SYN：该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。
- FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当收到 FIN 为 1 的报文段时表示「被动关闭连接」。

首部长度：
TCP（传输控制协议）在进行数据传输时需要使用首部（header）来携带必要的控制信息。首部长度是TCP首部的一个字段，用于指示首部的字节长度。
首部长度字段是一个4位的二进制数，它的取值范围是0-15。TCP首部的长度可以根据该字段的值来确定，它表示首部占据的32位字（4字节）的数量。
TCP首部的长度是可变的，它的最小长度是20字节（5个32位字），而最大长度是60字节（15个32位字）。首部长度的可变性允许TCP在不同的情况下携带不同数量的选项和扩展字段。
为什么TCP需要可变长度的首部呢？这是因为TCP协议需要灵活地适应不同的网络环境和需求。通过使用可变长度的首部，TCP可以在需要时添加额外的选项字段，以支持各种功能和扩展，如窗口缩放、选择性确认等。

在IP协议中，协议字段占8个位（即一个字节），用于指示封装在IP包中的上层协议。常见的协议及其协议编号如下：
- ICMP (Internet Control Message Protocol) - 协议编号 1
- IGMP (Internet Group Management Protocol) - 协议编号 2
- TCP (Transmission Control Protocol) - 协议编号 6
- UDP (User Datagram Protocol) - 协议编号 17
- GRE (Generic Routing Encapsulation) - 协议编号 47
- ESP (Encapsulating Security Payload) - 协议编号 50
- AH (Authentication Header) - 协议编号 51
- EIGRP (Enhanced Interior Gateway Routing Protocol) - 协议编号 88
- OSPF (Open Shortest Path First) - 协议编号 89
- SCTP (Stream Control Transmission Protocol) - 协议编号 132

## 存在必要性
IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。
如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 TCP 协议来负责。
因为 TCP 是一个工作在传输层的可靠数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。

## 与UDP区别
### UDP协议
UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。
UDP 协议真的非常简，头部只有 8 个字节（64 位），UDP 的头部格式如下：
![UDP头部](https://cdn.jsdelivr.net/gh/zysok2023/cloudImg/blogs/picture/UDP头部.webp)

- 目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。
- 包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。
- 校验和：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包。

### 对比
1. 连接
TCP 是面向连接的传输层协议，传输数据前先要建立连接。
UDP 是不需要连接，即刻传输数据。
2. 服务对象
TCP 是一对一的两点服务，即一条连接只有两个端点。
UDP 支持一对一、一对多、多对多的交互通信
3. 可靠性
TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。
UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：如何基于 UDP 协议实现可靠传输？
4. 拥塞控制、流量控制
TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。
5. 首部开销
TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。
UDP 首部只有 8 个字节，并且是固定不变的，开销较小。
6. 传输方式
TCP 是流式传输，没有边界，但保证顺序和可靠。
UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。
7. 分片不同
TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。
UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。

由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于FTP 文件传输、HTTP / HTTPS等。
由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于包总量较少的通信，如 DNS 、SNMP 、视频、音频等多媒体通信、广播通信等。

TCP数据的长度 = IP总长度 - IP头部长度 - TCP头部长度

## 连接
![三次握手](https://cdn.jsdelivr.net/gh/zysok2023/cloudImg/blogs/picture/三次握手.webp)

一开始，客户端和服务端都处于 CLOSE 状态。先是服务端主动监听某个端口，处于 LISTEN 状态
![三次握手第一个报文](https://cdn.jsdelivr.net/gh/zysok2023/cloudImg/blogs/picture/三次握手第一个报文.webp)

客户端会随机初始化序号（client_isn），将此序号置于 TCP 首部的「序号」字段中，同时把 SYN 标志位置为 1，表示 SYN 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 SYN-SENT 状态。

![三次握手第二个报文](https://cdn.jsdelivr.net/gh/zysok2023/cloudImg/blogs/picture/三次握手第二个报文.webp)
服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号（server_isn），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 client_isn + 1, 接着把 SYN 和 ACK 标志位置为 1。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 SYN-RCVD 状态。
![三次握手第三个报文](https://cdn.jsdelivr.net/gh/zysok2023/cloudImg/blogs/picture/三次握手第三个报文.webp)
客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 ACK 标志位置为 1 ，其次「确认应答号」字段填入 server_isn + 1 ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 ESTABLISHED 状态。

服务端收到客户端的应答报文后，也进入 ESTABLISHED 状态。
**第三次握手是可以携带数据的，前两次握手是不可以携带数据的**
一旦完成三次握手，双方都处于 ESTABLISHED 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。

Q1:如何在 Linux 系统中查看 TCP 状态？
TCP 的连接状态查看，在 Linux 可以通过 netstat -napt 命令查看。
Q2:为什么是三次握手？不是两次、四次？
- 三次握手才可以阻止重复历史连接的初始化（主要原因）
- 三次握手才可以同步双方的初始序列号
- 三次握手才可以避免资源浪费




